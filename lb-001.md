# Different Database Access Layer Strategies in This Codebase

This document explains the three different implementation strategies for database access and manipulation found in this codebase, in simple plain English.

## Strategy 1: Active Record Pattern
**Used in:** `Store` and `Product` modules

### How it works:
- The database table and the business object are combined into **one single class**
- The class itself knows how to save, update, and delete itself from the database
- Methods like `persist()`, `delete()`, `findById()`, and `listAll()` are called **directly on the entity object**

### Example from the code:
- `Store` entity extends `PanacheEntity` - it's both the data model AND knows how to interact with the database
- In `StoreResource.java`, you see code like:
  - `store.persist()` - the Store object saves itself
  - `Store.findById(id)` - calling database methods directly on the class
  - `Store.listAll()` - fetching data directly from the entity class

### In simple terms:
It's like a person who can save themselves to a filing cabinet - they don't need help from anyone else.

---

## Strategy 2: Repository Pattern with Separate Database Entities
**Used in:** `Warehouse` module

### How it works:
- You have **two separate classes**: 
  1. A **domain model** (`Warehouse`) - represents your business logic and rules
  2. A **database entity** (`DbWarehouse`) - represents how data is stored in the database
- A **Repository** class (`WarehouseRepository`) acts as a middleman that:
  - Converts between the domain model and database entity
  - Handles all database operations (save, find, delete)
  - Implements a clean interface (`WarehouseStore`) that defines what operations are available

### Example from the code:
- `Warehouse` - the business object (domain model)
- `DbWarehouse` - the database table representation
- `WarehouseRepository` - handles converting between them and doing database operations
- The business logic works with `Warehouse` objects, never touching `DbWarehouse` directly

### In simple terms:
It's like having a librarian (repository) who takes your book (domain object), catalogs it in their system (database entity), and stores it on the shelf. You just hand your book to the librarian and they handle the details.

---

## Strategy 3: In-Memory Data Store / Gateway Pattern
**Used in:** `Location` module

### How it works:
- Instead of using a real database, data is stored **in memory** (in a static list)
- A **Gateway class** (`LocationGateway`) provides methods to access this data
- The data is hardcoded and never changes (read-only)
- Implements an interface (`LocationResolver`) so other parts of the code don't need to know it's not a real database

### Example from the code:
- `LocationGateway` has a static list of `Location` objects hardcoded in the class
- It implements `LocationResolver` interface
- Method `resolveByIdentifier()` searches through the in-memory list to find locations

### In simple terms:
It's like having a cheat sheet taped to your desk with commonly used information - you don't need to look it up in a database, it's always right there in memory.

---

## Summary Comparison

| Strategy | Database Access | Separation of Concerns | Flexibility | Used In |
|----------|----------------|------------------------|-------------|---------|
| **Active Record** | Entity saves itself | Low (entity = database) | Simple, less flexible | Store, Product |
| **Repository Pattern** | Repository handles it | High (domain â‰  database) | Complex, very flexible | Warehouse |
| **In-Memory Gateway** | No real database | Medium | Fast, but read-only | Location |

---

## Why These Different Strategies Matter

The **inconsistency** in this codebase means:

1. **Different learning curves** - developers need to understand 3 different ways to access data
2. **Different testing approaches** - Active Record is harder to mock/test than Repository pattern
3. **Different flexibility** - Repository pattern allows you to change database structure without changing business logic
4. **Maintenance complexity** - Having multiple patterns makes the codebase harder to maintain

---

## Key Files Reference

### Active Record Pattern:
- [`Store.java`](file:///c:/Users/user/Documents/fcs-interview-code-assignment-main/fcs-interview-code-assignment-main/java-assignment/src/main/java/com/fulfilment/application/monolith/stores/Store.java)
- [`Product.java`](file:///c:/Users/user/Documents/fcs-interview-code-assignment-main/fcs-interview-code-assignment-main/java-assignment/src/main/java/com/fulfilment/application/monolith/products/Product.java)
- [`ProductRepository.java`](file:///c:/Users/user/Documents/fcs-interview-code-assignment-main/fcs-interview-code-assignment-main/java-assignment/src/main/java/com/fulfilment/application/monolith/products/ProductRepository.java)
- [`StoreResource.java`](file:///c:/Users/user/Documents/fcs-interview-code-assignment-main/fcs-interview-code-assignment-main/java-assignment/src/main/java/com/fulfilment/application/monolith/stores/StoreResource.java)

### Repository Pattern:
- [`Warehouse.java`](file:///c:/Users/user/Documents/fcs-interview-code-assignment-main/fcs-interview-code-assignment-main/java-assignment/src/main/java/com/fulfilment/application/monolith/warehouses/domain/models/Warehouse.java)
- [`DbWarehouse.java`](file:///c:/Users/user/Documents/fcs-interview-code-assignment-main/fcs-interview-code-assignment-main/java-assignment/src/main/java/com/fulfilment/application/monolith/warehouses/adapters/database/DbWarehouse.java)
- [`WarehouseRepository.java`](file:///c:/Users/user/Documents/fcs-interview-code-assignment-main/fcs-interview-code-assignment-main/java-assignment/src/main/java/com/fulfilment/application/monolith/warehouses/adapters/database/WarehouseRepository.java)

### In-Memory Gateway Pattern:
- [`LocationGateway.java`](file:///c:/Users/user/Documents/fcs-interview-code-assignment-main/fcs-interview-code-assignment-main/java-assignment/src/main/java/com/fulfilment/application/monolith/location/LocationGateway.java)

---

## Question to Consider

**If you would maintain this codebase, would you refactor any of those? Why?**

This is the key question - whether the benefits of consistency (choosing one pattern for everything) outweigh the cost of refactoring existing working code. Consider:
- **Team knowledge** - Does your team know all three patterns?
- **Maintenance burden** - Is the inconsistency causing real problems?
- **Testing needs** - Do you need better testability (favors Repository pattern)?
- **Future flexibility** - Will you need to change database implementations (favors Repository pattern)?
- **Simplicity** - Is the code simple enough that Active Record is sufficient?
